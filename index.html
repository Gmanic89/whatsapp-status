import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { Telegraf } from 'telegraf';
import cors from 'cors';
import multer from 'multer';
import dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: process.env.FRONTEND_URL || 'https://fortunawild.net',
    methods: ['GET', 'POST']
  }
});

// ConfiguraciÃ³n de Telegram Bot
const bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);
const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID;

// Middleware
app.use(cors());
app.use(express.json());

// Storage para multer (imÃ¡genes)
const storage = multer.memoryStorage();
const upload = multer({ 
  storage: storage,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB max
});

// Almacenamiento de sesiones activas
// Estructura: { socketId: { username, chatId, telegramMessageId } }
const activeSessions = new Map();
// Estructura inversa: { username: socketId }
const usernameToSocket = new Map();

// ===============================
// SOCKET.IO - Conexiones desde la web
// ===============================

io.on('connection', (socket) => {
  console.log('Nueva conexiÃ³n desde web:', socket.id);

  // Usuario se registra con su nombre/username
  socket.on('register', async (username) => {
    try {
      // Guardar sesiÃ³n
      activeSessions.set(socket.id, { 
        username, 
        connected: true,
        connectedAt: new Date()
      });
      usernameToSocket.set(username, socket.id);

      // Notificar al admin en Telegram
      const message = `ðŸŸ¢ Nuevo usuario conectado:\n\nðŸ‘¤ Usuario: ${username}\nâ° ${new Date().toLocaleString('es-AR')}`;
      
      const sentMessage = await bot.telegram.sendMessage(ADMIN_CHAT_ID, message);
      
      // Guardar el ID del mensaje para poder responder en contexto
      const session = activeSessions.get(socket.id);
      session.telegramMessageId = sentMessage.message_id;
      activeSessions.set(socket.id, session);

      socket.emit('registered', { success: true, username });
      console.log(`Usuario registrado: ${username}`);
    } catch (error) {
      console.error('Error al registrar usuario:', error);
      socket.emit('error', { message: 'Error al conectar con el sistema' });
    }
  });

  // Mensaje desde la web al admin
  socket.on('message', async (data) => {
    try {
      const session = activeSessions.get(socket.id);
      if (!session) {
        socket.emit('error', { message: 'No estÃ¡s registrado' });
        return;
      }

      const { message } = data;
      const username = session.username;

      // Enviar mensaje al admin en Telegram
      const telegramMessage = `ðŸ’¬ Mensaje de ${username}:\n\n${message}`;
      
      await bot.telegram.sendMessage(ADMIN_CHAT_ID, telegramMessage, {
        reply_markup: {
          inline_keyboard: [[
            { text: 'âœï¸ Responder', callback_data: `reply_${socket.id}` }
          ]]
        }
      });

      // Confirmar al usuario que se enviÃ³
      socket.emit('message_sent', { success: true });
      console.log(`Mensaje de ${username}: ${message}`);
    } catch (error) {
      console.error('Error al enviar mensaje:', error);
      socket.emit('error', { message: 'Error al enviar mensaje' });
    }
  });

  // Imagen desde la web
  socket.on('image', async (data) => {
    try {
      const session = activeSessions.get(socket.id);
      if (!session) {
        socket.emit('error', { message: 'No estÃ¡s registrado' });
        return;
      }

      const { imageData, caption } = data; // imageData es base64
      const username = session.username;

      // Convertir base64 a buffer
      const buffer = Buffer.from(imageData.split(',')[1], 'base64');

      // Enviar imagen al admin en Telegram
      const captionText = caption ? 
        `ðŸ“· Imagen de ${username}:\n\n${caption}` : 
        `ðŸ“· Imagen de ${username}`;

      await bot.telegram.sendPhoto(ADMIN_CHAT_ID, { source: buffer }, {
        caption: captionText,
        reply_markup: {
          inline_keyboard: [[
            { text: 'âœï¸ Responder', callback_data: `reply_${socket.id}` }
          ]]
        }
      });

      socket.emit('image_sent', { success: true });
      console.log(`Imagen recibida de ${username}`);
    } catch (error) {
      console.error('Error al enviar imagen:', error);
      socket.emit('error', { message: 'Error al enviar imagen' });
    }
  });

  // DesconexiÃ³n
  socket.on('disconnect', () => {
    const session = activeSessions.get(socket.id);
    if (session) {
      const username = session.username;
      usernameToSocket.delete(username);
      activeSessions.delete(socket.id);
      
      // Notificar al admin
      bot.telegram.sendMessage(ADMIN_CHAT_ID, 
        `ðŸ”´ Usuario desconectado:\n\nðŸ‘¤ ${username}\nâ° ${new Date().toLocaleString('es-AR')}`
      ).catch(err => console.error('Error notificando desconexiÃ³n:', err));
      
      console.log(`Usuario desconectado: ${username}`);
    }
  });
});

// ===============================
// TELEGRAM BOT - Respuestas del admin
// ===============================

// Cuando el admin responde a un mensaje del bot
bot.on('text', async (ctx) => {
  try {
    // Verificar que sea el admin
    if (ctx.chat.id.toString() !== ADMIN_CHAT_ID) {
      return;
    }

    // Verificar si estÃ¡ respondiendo a un mensaje
    if (!ctx.message.reply_to_message) {
      await ctx.reply('â„¹ï¸ Para responder a un usuario, usa "Responder" en el mensaje correspondiente.');
      return;
    }

    // Buscar a quÃ© usuario corresponde
    const replyText = ctx.message.reply_to_message.text;
    
    // Extraer username del mensaje original
    const usernameMatch = replyText.match(/(?:Usuario|Mensaje de|Imagen de):\s*([^\n:]+)/);
    
    if (!usernameMatch) {
      await ctx.reply('âŒ No pude identificar al usuario. Usa los botones de respuesta.');
      return;
    }

    const username = usernameMatch[1].trim();
    const socketId = usernameToSocket.get(username);

    if (!socketId || !activeSessions.has(socketId)) {
      await ctx.reply(`âŒ El usuario ${username} ya no estÃ¡ conectado.`);
      return;
    }

    // Enviar respuesta al usuario en la web
    const adminMessage = ctx.message.text;
    io.to(socketId).emit('admin_message', {
      message: adminMessage,
      timestamp: new Date()
    });

    await ctx.reply('âœ… Mensaje enviado a ' + username);
    console.log(`Admin respondiÃ³ a ${username}: ${adminMessage}`);
  } catch (error) {
    console.error('Error procesando mensaje del admin:', error);
    await ctx.reply('âŒ Error al enviar mensaje');
  }
});

// Cuando el admin envÃ­a una foto
bot.on('photo', async (ctx) => {
  try {
    if (ctx.chat.id.toString() !== ADMIN_CHAT_ID) {
      return;
    }

    if (!ctx.message.reply_to_message) {
      await ctx.reply('â„¹ï¸ Para enviar una foto a un usuario, responde a su mensaje.');
      return;
    }

    const replyText = ctx.message.reply_to_message.text || ctx.message.reply_to_message.caption || '';
    const usernameMatch = replyText.match(/(?:Usuario|Mensaje de|Imagen de):\s*([^\n:]+)/);
    
    if (!usernameMatch) {
      await ctx.reply('âŒ No pude identificar al usuario.');
      return;
    }

    const username = usernameMatch[1].trim();
    const socketId = usernameToSocket.get(username);

    if (!socketId || !activeSessions.has(socketId)) {
      await ctx.reply(`âŒ El usuario ${username} ya no estÃ¡ conectado.`);
      return;
    }

    // Obtener la foto
    const photo = ctx.message.photo[ctx.message.photo.length - 1]; // Mayor resoluciÃ³n
    const fileLink = await ctx.telegram.getFileLink(photo.file_id);
    
    // Descargar la imagen
    const response = await axios.get(fileLink.href, { responseType: 'arraybuffer' });
    const base64Image = Buffer.from(response.data).toString('base64');
    const imageData = `data:image/jpeg;base64,${base64Image}`;

    // Enviar al usuario
    io.to(socketId).emit('admin_image', {
      imageData,
      caption: ctx.message.caption || '',
      timestamp: new Date()
    });

    await ctx.reply('âœ… Imagen enviada a ' + username);
    console.log(`Admin enviÃ³ imagen a ${username}`);
  } catch (error) {
    console.error('Error enviando foto:', error);
    await ctx.reply('âŒ Error al enviar imagen');
  }
});

// Manejo de botones inline (callback_data)
bot.on('callback_query', async (ctx) => {
  try {
    const data = ctx.callbackQuery.data;
    
    if (data.startsWith('reply_')) {
      const socketId = data.replace('reply_', '');
      const session = activeSessions.get(socketId);
      
      if (!session) {
        await ctx.answerCbQuery('âŒ Usuario desconectado');
        return;
      }
      
      await ctx.answerCbQuery(`ðŸ’¬ Responde a este mensaje para contactar a ${session.username}`);
    }
  } catch (error) {
    console.error('Error en callback query:', error);
  }
});

// Iniciar bot con manejo de errores
bot.launch({
  dropPendingUpdates: true // Elimina actualizaciones pendientes
}).then(() => {
  console.log('ðŸ¤– Bot de Telegram conectado exitosamente');
}).catch((error) => {
  console.error('âŒ Error al iniciar bot de Telegram:', error.message);
  if (error.code === 409) {
    console.error('âš ï¸  Hay otra instancia del bot corriendo. CerrÃ¡ otras instancias y volvÃ© a intentar.');
    console.error('ðŸ’¡ EjecutÃ¡: pkill node (Mac/Linux) o taskkill /F /IM node.exe (Windows)');
  }
  process.exit(1);
});

// ===============================
// RUTAS DE API
// ===============================

app.get('/', (req, res) => {
  res.json({ 
    status: 'online',
    service: 'FortunaWild Chat Backend',
    activeUsers: activeSessions.size
  });
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok',
    activeUsers: activeSessions.size,
    timestamp: new Date()
  });
});

// Endpoint para subir imÃ¡genes vÃ­a HTTP (alternativa)
app.post('/upload-image', upload.single('image'), async (req, res) => {
  try {
    const { username, caption } = req.body;
    
    if (!req.file) {
      return res.status(400).json({ error: 'No se recibiÃ³ imagen' });
    }

    const captionText = caption ? 
      `ðŸ“· Imagen de ${username}:\n\n${caption}` : 
      `ðŸ“· Imagen de ${username}`;

    await bot.telegram.sendPhoto(ADMIN_CHAT_ID, { source: req.file.buffer }, {
      caption: captionText
    });

    res.json({ success: true });
  } catch (error) {
    console.error('Error al subir imagen:', error);
    res.status(500).json({ error: 'Error al procesar imagen' });
  }
});

// ===============================
// INICIAR SERVIDOR
// ===============================

const PORT = process.env.PORT || 3000;

httpServer.listen(PORT, () => {
  console.log(`âœ… Servidor corriendo en puerto ${PORT}`);
  console.log(`ðŸ¤– Bot de Telegram iniciado`);
  console.log(`ðŸ‘¥ Usuarios activos: ${activeSessions.size}`);
});

// Manejo de errores
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));